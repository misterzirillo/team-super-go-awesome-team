class GA(EA):
    
    def __init__(self, shape, maxGen):
        #super(shape, max)
        self.shape=shape
        self.maxGen=maxGen
        super().__init__(self.shape, self.maxGen)
        
    
    def train(self, train_set, validation_set):
        super().train()
        #initialize random population
        #10*number of dimensions
        self.pop = initializePop(self, sum(self.shape))
        
        #mark the time step, or generation
        t = 0
        
        self.fitness={}
        self.fitnext={}
        #evaluate the fitness of the population
        for i in range(len(self.pop)):
            fitness.update({i : self.evaluateFitness(pop[i])})
        
        #sort by fitness
        self.sortFit = sorted(fitness.items(), key=lambda x:x[1])
        
        #store current best individual
        best = max(fitness.iterkeys(), key=(lambda key: stats[key]))

        while(t <= self.maxGen):
            #create test_fold
            t = t +1
            self.parents = self.selectFrom()
            offSpring = self.crossOver()
            newPop = self.mutate(offSpring)
            for i in range(len(newPop)):
                self.fitness.update({i : self.evaluateFitness(newPop[i])})
            
            self.sortFit = sorted(fitness.items(), key=lambda x:x[1])
            self.sortFit = self.sortFit[len(newPop):]
            
            if(t== self.maxGen):
                return(best)
    
    
        #generate a random population
    def initializePop(self, mu):
        numWeights = sum([self.shape[i] * self.shape(i + 1) for i in range(len(self.shape - 1))])
        self.pop = [np.random.uniform(size=numWeights) for i in range(mu)]
          
    #evaluate the fitness of the population on some loss function
    def evaluateFitness(self, individual, x, y): 
        correctIndex = y.index(max(y)) # [0, 0, 1] -> 2
        hypothesis = individual.propagate(x)
        hypothesizedIndex = hypothesis.index(max(hypothesis))
        return sum(correctIndex == hypothesizedIndex) / len(y or x)
    
    #select the parents from the population
    #rank based

    def selectFrom(self):
        super().selectFrom()
        n = len(self.pop)
        #expected number of offspring generated by the best individual
        lam1 = 1.99
        #expected number of offspring generated by the best individual
        lam2 = 2-lam1
   
        Pxi = []
        wheel = []
        #assign probability of selection
        #calculate cumulative fitness and make roulette wheel
        for i in range(0, n-1):
            #normalizer
            Pxi.append((lam2 + (i/(n-1))(lam1 - lam2))/ n)
            wheel.append((sum(Pxi), self.sortFit[i[0]]))
        
        #generate two random numbers in the range of the wheel to find parents        
        num = np.random(0, sum(Pxi))
        i = 0
        while(True):
            if wheel[i[0]] > num:
                self.parent[0] = wheel[i[1]]
                break
            else:
                i = i+1
        i=0
        num = np.random(0, sum(Pxi))
        while(True): 
            if wheel[i[0]] > num:
                if(wheel[i[0]]!=self.parent[0]):
                    self.parent[1] = wheel[i[1]]
                    break
                else:
                    num = np.random(0, sum(Pxi))
                    i=0
            else:
                i=i+1
        
    #generate offspring according to the crossover rate
    #global, uniform
    # should return a whole new copy of the population
    # example: self.pop = self.crossOver()
    def crossOver(self):
        super().crossOver()
        
        offspring=[]
        #generate offspring
        for i in range(0,len(self.parents)-1):
            if (i % 2) == 0:
                offspring.append(self.uniCross(0))
            else:
                offspring.append(self.uniCross(1))
        return(offspring)
        
    
    def uniCross(self, n):
        babe=[]
        mask = np.randint(0, 1, len(self.parents[0]))
        
        if n == 0:
            for i in range(len(self.parents[0])):
                if mask[i] == 1:
                    babe.append(self.parents[0][i])
                else:
                    babe.append(self.parents[1][i])
        else:
            for i in range(len(x1)):
                if mask[i] == 1:
                    babe.append(self.parents[1][i])
                else:
                    babe.append(self.parents[0][i])
        return babe
        

    #mutate the offspring according to the mutation rate
    # should return a whole new copy of the population
    # example: self.pop = self.mutate()

    def mutate(self, specimens):
        super().mutate()
        Pm =.1
        for i in range(len(specimens)-1):
            for j in range(len(specimens[i])):
                num = np.random(0,1)
                if(num < Pm):
                    specimen[i[j]] = np.random.normal(loc=specimen[i[j]])
        return(specimens)
                    
    #find the slackers and replace them with new dudes
    def replace(self, newPop, fitNext):
        
        for i in range(len(newPop)-1):
            
            
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
                
            
    